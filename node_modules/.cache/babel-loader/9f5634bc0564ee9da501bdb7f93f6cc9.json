{"ast":null,"code":"import _assertThisInitialized from \"C:\\\\Users\\\\aida\\\\OneDrive\\\\Aidoo\\\\Project\\\\Replace Image\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"C:\\\\Users\\\\aida\\\\OneDrive\\\\Aidoo\\\\Project\\\\Replace Image\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\aida\\\\OneDrive\\\\Aidoo\\\\Project\\\\Replace Image\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\aida\\\\OneDrive\\\\Aidoo\\\\Project\\\\Replace Image\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\aida\\\\OneDrive\\\\Aidoo\\\\Project\\\\Replace Image\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"C:\\\\Users\\\\aida\\\\OneDrive\\\\Aidoo\\\\Project\\\\Replace Image\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\aida\\\\OneDrive\\\\Aidoo\\\\Project\\\\Replace Image\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { defineHidden, is, createInterpolator, each, getFluidConfig, isAnimatedString, useForceUpdate } from '@react-spring/shared';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { frameLoop } from '@react-spring/shared/globals';\nimport { forwardRef, useRef, createElement } from 'react';\nimport { useLayoutEffect } from 'react-layout-effect';\nvar $node = Symbol.for('Animated:node');\n\nvar isAnimated = function isAnimated(value) {\n  return !!value && value[$node] === value;\n};\n/** Get the owner's `Animated` node. */\n\n\nvar getAnimated = function getAnimated(owner) {\n  return owner && owner[$node];\n};\n/** Set the owner's `Animated` node. */\n\n\nvar setAnimated = function setAnimated(owner, node) {\n  return defineHidden(owner, $node, node);\n};\n/** Get every `AnimatedValue` in the owner's `Animated` node. */\n\n\nvar getPayload = function getPayload(owner) {\n  return owner && owner[$node] && owner[$node].getPayload();\n};\n\nvar Animated = /*#__PURE__*/function () {\n  /** The cache of animated values */\n  function Animated() {\n    _classCallCheck(this, Animated);\n\n    this.payload = void 0; // This makes \"isAnimated\" return true.\n\n    setAnimated(this, this);\n  }\n  /** Get the current value. Pass `true` for only animated values. */\n\n  /** Get every `AnimatedValue` used by this node. */\n\n\n  _createClass(Animated, [{\n    key: \"getPayload\",\n    value: function getPayload() {\n      return this.payload || [];\n    }\n  }]);\n\n  return Animated;\n}();\n/** An animated number or a native attribute value */\n\n\nvar AnimatedValue = /*#__PURE__*/function (_Animated) {\n  _inherits(AnimatedValue, _Animated);\n\n  var _super = _createSuper(AnimatedValue);\n\n  function AnimatedValue(_value) {\n    var _this;\n\n    _classCallCheck(this, AnimatedValue);\n\n    _this = _super.call(this);\n    _this._value = _value;\n    _this.done = true;\n    _this.elapsedTime = void 0;\n    _this.lastPosition = void 0;\n    _this.lastVelocity = void 0;\n    _this.v0 = void 0;\n\n    if (is.num(_this._value)) {\n      _this.lastPosition = _this._value;\n    }\n\n    return _this;\n  }\n\n  _createClass(AnimatedValue, [{\n    key: \"getPayload\",\n    value: function getPayload() {\n      return [this];\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this._value;\n    }\n    /**\n     * Set the current value and optionally round it.\n     *\n     * The `step` argument does nothing whenever it equals `undefined` or `0`.\n     * It works with fractions and whole numbers. The best use case is (probably)\n     * rounding to the pixel grid with a step of:\n     *\n     *      1 / window.devicePixelRatio\n     */\n\n  }, {\n    key: \"setValue\",\n    value: function setValue(value, step) {\n      if (is.num(value)) {\n        this.lastPosition = value;\n\n        if (step) {\n          value = Math.round(value / step) * step;\n\n          if (this.done) {\n            this.lastPosition = value;\n          }\n        }\n      }\n\n      if (this._value === value) {\n        return false;\n      }\n\n      this._value = value;\n      return true;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var done = this.done;\n      this.done = false;\n\n      if (is.num(this._value)) {\n        this.elapsedTime = 0;\n        this.lastPosition = this._value;\n        if (done) this.lastVelocity = null;\n        this.v0 = null;\n      }\n    }\n  }], [{\n    key: \"create\",\n    value: function create(from, _to) {\n      return new AnimatedValue(from);\n    }\n  }]);\n\n  return AnimatedValue;\n}(Animated);\n\nvar AnimatedString = /*#__PURE__*/function (_AnimatedValue) {\n  _inherits(AnimatedString, _AnimatedValue);\n\n  var _super2 = _createSuper(AnimatedString);\n\n  function AnimatedString(from, to) {\n    var _this2;\n\n    _classCallCheck(this, AnimatedString);\n\n    _this2 = _super2.call(this, 0);\n    _this2._value = void 0;\n    _this2._string = null;\n    _this2._toString = void 0;\n    _this2._toString = createInterpolator({\n      output: [from, to]\n    });\n    return _this2;\n  }\n\n  _createClass(AnimatedString, [{\n    key: \"getValue\",\n    value: function getValue() {\n      var value = this._string;\n      return value == null ? this._string = this._toString(this._value) : value;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value) {\n      if (!is.num(value)) {\n        this._string = value;\n        this._value = 1;\n      } else if (_get(_getPrototypeOf(AnimatedString.prototype), \"setValue\", this).call(this, value)) {\n        this._string = null;\n      } else {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(goal) {\n      if (goal) {\n        this._toString = createInterpolator({\n          output: [this.getValue(), goal]\n        });\n      }\n\n      this._value = 0;\n\n      _get(_getPrototypeOf(AnimatedString.prototype), \"reset\", this).call(this);\n    }\n  }], [{\n    key: \"create\",\n    value: function create(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n\n      if (is.str(from) && is.str(to)) {\n        return new AnimatedString(from, to);\n      }\n\n      throw TypeError('Expected \"from\" and \"to\" to be strings');\n    }\n  }]);\n\n  return AnimatedString;\n}(AnimatedValue);\n\nvar TreeContext = {\n  current: null\n};\n/** An object containing `Animated` nodes */\n\nvar AnimatedObject = /*#__PURE__*/function (_Animated2) {\n  _inherits(AnimatedObject, _Animated2);\n\n  var _super3 = _createSuper(AnimatedObject);\n\n  function AnimatedObject() {\n    var _this3;\n\n    var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, AnimatedObject);\n\n    _this3 = _super3.call(this);\n    _this3.source = void 0;\n\n    _this3.setValue(source);\n\n    return _this3;\n  }\n\n  _createClass(AnimatedObject, [{\n    key: \"getValue\",\n    value: function getValue(animated) {\n      if (!this.source) return null;\n      var values = {};\n      each(this.source, function (source, key) {\n        if (isAnimated(source)) {\n          values[key] = source.getValue(animated);\n        } else {\n          var config = getFluidConfig(source);\n\n          if (config) {\n            values[key] = config.get();\n          } else if (!animated) {\n            values[key] = source;\n          }\n        }\n      });\n      return values;\n    }\n    /** Replace the raw object data */\n\n  }, {\n    key: \"setValue\",\n    value: function setValue(source) {\n      this.source = source;\n      this.payload = this._makePayload(source);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.payload) {\n        each(this.payload, function (node) {\n          return node.reset();\n        });\n      }\n    }\n    /** Create a payload set. */\n\n  }, {\n    key: \"_makePayload\",\n    value: function _makePayload(source) {\n      if (source) {\n        var payload = new Set();\n        each(source, this._addToPayload, payload);\n        return Array.from(payload);\n      }\n    }\n    /** Add to a payload set. */\n\n  }, {\n    key: \"_addToPayload\",\n    value: function _addToPayload(source) {\n      var _this4 = this;\n\n      var config = getFluidConfig(source);\n\n      if (config && TreeContext.current) {\n        TreeContext.current.dependencies.add(source);\n      }\n\n      var payload = getPayload(source);\n\n      if (payload) {\n        each(payload, function (node) {\n          return _this4.add(node);\n        });\n      }\n    }\n  }]);\n\n  return AnimatedObject;\n}(Animated);\n/** An array of animated nodes */\n\n\nvar AnimatedArray = /*#__PURE__*/function (_AnimatedObject) {\n  _inherits(AnimatedArray, _AnimatedObject);\n\n  var _super4 = _createSuper(AnimatedArray);\n\n  function AnimatedArray(from, to) {\n    var _thisSuper, _this5;\n\n    _classCallCheck(this, AnimatedArray);\n\n    _this5 = _super4.call(this, null);\n    _this5.source = void 0;\n\n    _get((_thisSuper = _assertThisInitialized(_this5), _getPrototypeOf(AnimatedArray.prototype)), \"setValue\", _thisSuper).call(_thisSuper, _this5._makeAnimated(from, to));\n\n    return _this5;\n  }\n\n  _createClass(AnimatedArray, [{\n    key: \"getValue\",\n    value: function getValue() {\n      return this.source.map(function (node) {\n        return node.getValue();\n      });\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(newValue) {\n      var payload = this.getPayload(); // Reuse the payload when lengths are equal.\n\n      if (newValue && newValue.length == payload.length) {\n        each(payload, function (node, i) {\n          return node.setValue(newValue[i]);\n        });\n      } else {\n        // Remake the payload when length changes.\n        this.source = this._makeAnimated(newValue);\n        this.payload = this._makePayload(this.source);\n      }\n    }\n    /** Convert the `from` and `to` values to an array of `Animated` nodes */\n\n  }, {\n    key: \"_makeAnimated\",\n    value: function _makeAnimated(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n      return from ? from.map(function (from, i) {\n        return (isAnimatedString(from) ? AnimatedString : AnimatedValue).create(from, to[i]);\n      }) : [];\n    }\n  }], [{\n    key: \"create\",\n    value: function create(from, to) {\n      return new AnimatedArray(from, to);\n    }\n  }]);\n\n  return AnimatedArray;\n}(AnimatedObject);\n\nvar AnimatedProps = /*#__PURE__*/function (_AnimatedObject2) {\n  _inherits(AnimatedProps, _AnimatedObject2);\n\n  var _super5 = _createSuper(AnimatedProps);\n\n  /** Equals true when an update is scheduled for \"end of frame\" */\n  function AnimatedProps(update) {\n    var _this6;\n\n    _classCallCheck(this, AnimatedProps);\n\n    _this6 = _super5.call(this, null);\n    _this6.update = update;\n    _this6.dirty = false;\n    return _this6;\n  }\n\n  _createClass(AnimatedProps, [{\n    key: \"setValue\",\n    value: function setValue(props, context) {\n      if (!props) return; // The constructor passes null.\n\n      if (context) {\n        TreeContext.current = context;\n\n        if (props.style) {\n          var createAnimatedStyle = context.host.createAnimatedStyle;\n          props = _extends(_extends({}, props), {}, {\n            style: createAnimatedStyle(props.style)\n          });\n        }\n      }\n\n      _get(_getPrototypeOf(AnimatedProps.prototype), \"setValue\", this).call(this, props);\n\n      TreeContext.current = null;\n    }\n    /** @internal */\n\n  }, {\n    key: \"onParentChange\",\n    value: function onParentChange(_ref) {\n      var _this7 = this;\n\n      var type = _ref.type;\n\n      if (!this.dirty && type === 'change') {\n        this.dirty = true;\n        frameLoop.onFrame(function () {\n          _this7.dirty = false;\n\n          _this7.update();\n        });\n      }\n    }\n  }]);\n\n  return AnimatedProps;\n}(AnimatedObject);\n\nvar withAnimated = function withAnimated(Component, host) {\n  return forwardRef(function (rawProps, ref) {\n    var instanceRef = useRef(null);\n    var hasInstance = // Function components must use \"forwardRef\" to avoid being\n    // re-rendered on every animation frame.\n    !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n    var forceUpdate = useForceUpdate();\n    var props = new AnimatedProps(function () {\n      var instance = instanceRef.current;\n\n      if (hasInstance && !instance) {\n        return; // The wrapped component forgot to forward its ref.\n      }\n\n      var didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false; // Re-render the component when native updates fail.\n\n      if (didUpdate === false) {\n        forceUpdate();\n      }\n    });\n    var dependencies = new Set();\n    props.setValue(rawProps, {\n      dependencies: dependencies,\n      host: host\n    });\n    useLayoutEffect(function () {\n      each(dependencies, function (dep) {\n        return dep.addChild(props);\n      });\n      return function () {\n        return each(dependencies, function (dep) {\n          return dep.removeChild(props);\n        });\n      };\n    });\n    return /*#__PURE__*/createElement(Component, _extends({}, host.getComponentProps(props.getValue()), {\n      ref: hasInstance && function (value) {\n        instanceRef.current = updateRef(ref, value);\n      }\n    }));\n  });\n};\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n} // For storing the animated version on the original component\n\n\nvar cacheKey = Symbol.for('AnimatedComponent');\n\nvar createHost = function createHost(components) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref2$applyAnimatedVa = _ref2.applyAnimatedValues,\n      applyAnimatedValues = _ref2$applyAnimatedVa === void 0 ? function () {\n    return false;\n  } : _ref2$applyAnimatedVa,\n      _ref2$createAnimatedS = _ref2.createAnimatedStyle,\n      createAnimatedStyle = _ref2$createAnimatedS === void 0 ? function (style) {\n    return new AnimatedObject(style);\n  } : _ref2$createAnimatedS,\n      _ref2$getComponentPro = _ref2.getComponentProps,\n      getComponentProps = _ref2$getComponentPro === void 0 ? function (props) {\n    return props;\n  } : _ref2$getComponentPro;\n\n  var hostConfig = {\n    applyAnimatedValues: applyAnimatedValues,\n    createAnimatedStyle: createAnimatedStyle,\n    getComponentProps: getComponentProps\n  };\n\n  var animated = function animated(Component) {\n    var displayName = getDisplayName(Component) || 'Anonymous';\n\n    if (is.str(Component)) {\n      Component = withAnimated(Component, hostConfig);\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n\n    Component.displayName = \"Animated(\" + displayName + \")\";\n    return Component;\n  };\n\n  each(components, function (Component, key) {\n    if (!is.str(key)) {\n      key = getDisplayName(Component);\n    }\n\n    animated[key] = animated(Component);\n  });\n  return {\n    animated: animated\n  };\n};\n\nvar getDisplayName = function getDisplayName(arg) {\n  return is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n};\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedProps, AnimatedString, AnimatedValue, createHost, getAnimated, getPayload, isAnimated, setAnimated };","map":{"version":3,"sources":["src/Animated.ts","src/AnimatedValue.ts","src/AnimatedString.ts","src/context.ts","src/AnimatedObject.ts","src/AnimatedArray.ts","src/AnimatedProps.ts","src/withAnimated.tsx","src/createHost.ts"],"names":["$node","Symbol","isAnimated","value","getAnimated","owner","setAnimated","defineHidden","getPayload","payload","constructor","done","elapsedTime","lastPosition","lastVelocity","v0","_value","is","getValue","setValue","Math","reset","_string","_toString","createInterpolator","output","to","TypeError","TreeContext","current","source","values","each","config","getFluidConfig","node","Array","newValue","from","isAnimatedString","dirty","update","props","createAnimatedStyle","context","style","onParentChange","type","G","withAnimated","forwardRef","instanceRef","useRef","hasInstance","Component","forceUpdate","useForceUpdate","instance","didUpdate","host","dependencies","useLayoutEffect","dep","updateRef","ref","cacheKey","createHost","applyAnimatedValues","getComponentProps","hostConfig","animated","displayName","getDisplayName","key","arg"],"mappings":"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","sourcesContent":["import { defineHidden, is, createInterpolator, each, getFluidConfig, isAnimatedString, useForceUpdate } from '@react-spring/shared';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { frameLoop } from '@react-spring/shared/globals';\nimport { forwardRef, useRef, createElement } from 'react';\nimport { useLayoutEffect } from 'react-layout-effect';\n\nconst $node = Symbol.for('Animated:node');\nconst isAnimated = value => !!value && value[$node] === value;\n/** Get the owner's `Animated` node. */\n\nconst getAnimated = owner => owner && owner[$node];\n/** Set the owner's `Animated` node. */\n\nconst setAnimated = (owner, node) => defineHidden(owner, $node, node);\n/** Get every `AnimatedValue` in the owner's `Animated` node. */\n\nconst getPayload = owner => owner && owner[$node] && owner[$node].getPayload();\nclass Animated {\n  /** The cache of animated values */\n  constructor() {\n    this.payload = void 0;\n    // This makes \"isAnimated\" return true.\n    setAnimated(this, this);\n  }\n  /** Get the current value. Pass `true` for only animated values. */\n\n\n  /** Get every `AnimatedValue` used by this node. */\n  getPayload() {\n    return this.payload || [];\n  }\n\n}\n\n/** An animated number or a native attribute value */\n\nclass AnimatedValue extends Animated {\n  constructor(_value) {\n    super();\n    this._value = _value;\n    this.done = true;\n    this.elapsedTime = void 0;\n    this.lastPosition = void 0;\n    this.lastVelocity = void 0;\n    this.v0 = void 0;\n\n    if (is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n\n  static create(from, _to) {\n    return new AnimatedValue(from);\n  }\n\n  getPayload() {\n    return [this];\n  }\n\n  getValue() {\n    return this._value;\n  }\n  /**\n   * Set the current value and optionally round it.\n   *\n   * The `step` argument does nothing whenever it equals `undefined` or `0`.\n   * It works with fractions and whole numbers. The best use case is (probably)\n   * rounding to the pixel grid with a step of:\n   *\n   *      1 / window.devicePixelRatio\n   */\n\n\n  setValue(value, step) {\n    if (is.num(value)) {\n      this.lastPosition = value;\n\n      if (step) {\n        value = Math.round(value / step) * step;\n\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n\n    if (this._value === value) {\n      return false;\n    }\n\n    this._value = value;\n    return true;\n  }\n\n  reset() {\n    const {\n      done\n    } = this;\n    this.done = false;\n\n    if (is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.lastPosition = this._value;\n      if (done) this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n\n}\n\nclass AnimatedString extends AnimatedValue {\n  constructor(from, to) {\n    super(0);\n    this._value = void 0;\n    this._string = null;\n    this._toString = void 0;\n    this._toString = createInterpolator({\n      output: [from, to]\n    });\n  }\n\n  static create(from, to = from) {\n    if (is.str(from) && is.str(to)) {\n      return new AnimatedString(from, to);\n    }\n\n    throw TypeError('Expected \"from\" and \"to\" to be strings');\n  }\n\n  getValue() {\n    let value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n\n  setValue(value) {\n    if (!is.num(value)) {\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  reset(goal) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal]\n      });\n    }\n\n    this._value = 0;\n    super.reset();\n  }\n\n}\n\nconst TreeContext = {\n  current: null\n};\n\n/** An object containing `Animated` nodes */\nclass AnimatedObject extends Animated {\n  constructor(source = null) {\n    super();\n    this.source = void 0;\n    this.setValue(source);\n  }\n\n  getValue(animated) {\n    if (!this.source) return null;\n    const values = {};\n    each(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else {\n        const config = getFluidConfig(source);\n\n        if (config) {\n          values[key] = config.get();\n        } else if (!animated) {\n          values[key] = source;\n        }\n      }\n    });\n    return values;\n  }\n  /** Replace the raw object data */\n\n\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset());\n    }\n  }\n  /** Create a payload set. */\n\n\n  _makePayload(source) {\n    if (source) {\n      const payload = new Set();\n      each(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n  /** Add to a payload set. */\n\n\n  _addToPayload(source) {\n    const config = getFluidConfig(source);\n\n    if (config && TreeContext.current) {\n      TreeContext.current.dependencies.add(source);\n    }\n\n    const payload = getPayload(source);\n\n    if (payload) {\n      each(payload, node => this.add(node));\n    }\n  }\n\n}\n\n/** An array of animated nodes */\nclass AnimatedArray extends AnimatedObject {\n  constructor(from, to) {\n    super(null);\n    this.source = void 0;\n    super.setValue(this._makeAnimated(from, to));\n  }\n\n  static create(from, to) {\n    return new AnimatedArray(from, to);\n  }\n\n  getValue() {\n    return this.source.map(node => node.getValue());\n  }\n\n  setValue(newValue) {\n    const payload = this.getPayload(); // Reuse the payload when lengths are equal.\n\n    if (newValue && newValue.length == payload.length) {\n      each(payload, (node, i) => node.setValue(newValue[i]));\n    } else {\n      // Remake the payload when length changes.\n      this.source = this._makeAnimated(newValue);\n      this.payload = this._makePayload(this.source);\n    }\n  }\n  /** Convert the `from` and `to` values to an array of `Animated` nodes */\n\n\n  _makeAnimated(from, to = from) {\n    return from ? from.map((from, i) => (isAnimatedString(from) ? AnimatedString : AnimatedValue).create(from, to[i])) : [];\n  }\n\n}\n\nclass AnimatedProps extends AnimatedObject {\n  /** Equals true when an update is scheduled for \"end of frame\" */\n  constructor(update) {\n    super(null);\n    this.update = update;\n    this.dirty = false;\n  }\n\n  setValue(props, context) {\n    if (!props) return; // The constructor passes null.\n\n    if (context) {\n      TreeContext.current = context;\n\n      if (props.style) {\n        const {\n          createAnimatedStyle\n        } = context.host;\n        props = _extends(_extends({}, props), {}, {\n          style: createAnimatedStyle(props.style)\n        });\n      }\n    }\n\n    super.setValue(props);\n    TreeContext.current = null;\n  }\n  /** @internal */\n\n\n  onParentChange({\n    type\n  }) {\n    if (!this.dirty && type === 'change') {\n      this.dirty = true;\n      frameLoop.onFrame(() => {\n        this.dirty = false;\n        this.update();\n      });\n    }\n  }\n\n}\n\nconst withAnimated = (Component, host) => forwardRef((rawProps, ref) => {\n  const instanceRef = useRef(null);\n  const hasInstance = // Function components must use \"forwardRef\" to avoid being\n  // re-rendered on every animation frame.\n  !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  const forceUpdate = useForceUpdate();\n  const props = new AnimatedProps(() => {\n    const instance = instanceRef.current;\n\n    if (hasInstance && !instance) {\n      return; // The wrapped component forgot to forward its ref.\n    }\n\n    const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false; // Re-render the component when native updates fail.\n\n    if (didUpdate === false) {\n      forceUpdate();\n    }\n  });\n  const dependencies = new Set();\n  props.setValue(rawProps, {\n    dependencies,\n    host\n  });\n  useLayoutEffect(() => {\n    each(dependencies, dep => dep.addChild(props));\n    return () => each(dependencies, dep => dep.removeChild(props));\n  });\n  return /*#__PURE__*/createElement(Component, _extends({}, host.getComponentProps(props.getValue()), {\n    ref: hasInstance && (value => {\n      instanceRef.current = updateRef(ref, value);\n    })\n  }));\n});\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n}\n\n// For storing the animated version on the original component\nconst cacheKey = Symbol.for('AnimatedComponent');\nconst createHost = (components, {\n  applyAnimatedValues = () => false,\n  createAnimatedStyle = style => new AnimatedObject(style),\n  getComponentProps = props => props\n} = {}) => {\n  const hostConfig = {\n    applyAnimatedValues,\n    createAnimatedStyle,\n    getComponentProps\n  };\n\n  const animated = Component => {\n    const displayName = getDisplayName(Component) || 'Anonymous';\n\n    if (is.str(Component)) {\n      Component = withAnimated(Component, hostConfig);\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n\n    Component.displayName = \"Animated(\" + displayName + \")\";\n    return Component;\n  };\n\n  each(components, (Component, key) => {\n    if (!is.str(key)) {\n      key = getDisplayName(Component);\n    }\n\n    animated[key] = animated(Component);\n  });\n  return {\n    animated\n  };\n};\n\nconst getDisplayName = arg => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedProps, AnimatedString, AnimatedValue, createHost, getAnimated, getPayload, isAnimated, setAnimated };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}